<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE suite SYSTEM "../../drivers/testng-1.0.dtd">
<suite name="Suite" data-provider-thread-count="1">
<parameter name="SuiteName" value="Create Policy" />
<parameter name="xlsxFilePath" value="${user.dir}\\inputFiles\\NYLRL_Transactions\\RL_TestData.xlsx"/>
<parameter name="policyData" value="PolicyData"/>
<parameter name="templateDir" value="${user.dir}\\inputFiles\\NYLRL_Transactions\\XML_Templates"/>
  <test name="Test">
    <classes>
      <class name="test.fast.CreatePolicyforLife.CreatePolicy"/>
    </classes>
  </test> <!-- Test -->
</suite> <!-- Suite -->






package test.fast.CreatePolicyforLife;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.io.FileUtils;
import org.apache.hc.client5.http.classic.methods.HttpPost;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.CloseableHttpResponse;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.http.io.entity.StringEntity;
import org.apache.hc.core5.http.io.entity.EntityUtils;
import org.apache.hc.core5.http.ContentType;
import org.json.JSONObject;
import org.openqa.selenium.OutputType;
import org.openqa.selenium.TakesScreenshot;
import org.openqa.selenium.WebDriver;
import org.testng.Assert;
import org.testng.ITestContext;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.AfterClass;
import org.testng.annotations.Parameters;
import org.testng.annotations.Test;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import com.nyl.base.WebBase;
import com.nyl.utilities.EnvParameters;
import com.relevantcodes.extentreports.ExtentReports;
import com.relevantcodes.extentreports.ExtentTest;
import com.relevantcodes.extentreports.LogStatus;
import com.relevantcodes.extentreports.model.ITest;
import com.relevantcodes.extentreports.model.Log;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;
import java.util.stream.IntStream;

public class CreatePolicy extends WebBase {

	private Document doc;
	private String templateDir;
	private String token;

	public static ExtentReports mainReport;
	public HashMap<String, Integer> testCaseRetryCount = new HashMap<String, Integer>();
	public String folderPath;

	ExtentTest subTest = null;
	ExtentTest test = null;
	ExtentReports report;
	
	@Parameters("templateDir")
	@BeforeClass(alwaysRun = true)
	public void reportInitialization(String templateDir) throws Exception {
		this.templateDir = templateDir;
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HHmmss");
		LocalDateTime now = LocalDateTime.now();
		folderPath = ".//Reports/Functional Test Reports/CreatePolicyWithAPI/Test Report_" + dtf.format(now);
		fileName = folderPath + "/CreatePolicyWithAPI.html";
		mainReport = new ExtentReports(fileName);
		mainReport.loadConfig(new File(".//Config Files/Functional Test Report-config.xml"));
		
		report = new ExtentReports("dummy.html");
		test = report.startTest("Policy Creation Test Report");
		subTest = report.startTest("Token Generation Test");
		subTest.log(LogStatus.INFO, "Generating bearer token");

		try {
			this.token = getBearerToken();
			subTest.log(LogStatus.PASS, "Bearer token generated successfully");
		} catch (Exception e) {
			subTest.log(LogStatus.FAIL, "Bearer token generation failed: "+
			e.getMessage());
			throw e;
		}

		test.appendChild(subTest);
		report.endTest(subTest);
	}

	@Test(dataProvider = "xmlUpdateData", dataProviderClass = fast.dataProviders.ReadDataFromXLSX.class)
	public void updateXML(String testCaseName, String templateName, List<Object[]> updates) throws Exception {

		//ExtentReports report = new ExtentReports("dummy.html");
		test = report.startTest("Policy Creation");

		// Load the XML template for each test case
		loadTemplate(templateName);

		// Extract PolNumber from Node1_Value (first update entry's newValue)
		String polNumber = (String) updates.get(0)[2];

		subTest = report.startTest("Policy Creation Test for " + polNumber);

		// Update XML nodes based on test data
		for (Object[] update : updates) {
			String nodeName = (String) update[0];
			String attributeName = (String) update[1];
			String newValue = (String) update[2];
			String condition = update.length > 3 ? (String) update[3] : "";

			NodeList nodeList = doc.getElementsByTagName(nodeName);

			IntStream.range(0, nodeList.getLength()).mapToObj(nodeList::item).filter(node -> node instanceof Element)
					.map(node -> (Element) node).filter(element -> matchesCondition(element, condition)) // Only update
																											// if
																											// condition
																											// matches
					.forEach(element -> {
						if (attributeName.isEmpty()) {
							// If newValue is blank, clear the node content
							if (newValue.isEmpty()) {
								element.setTextContent(""); // Set node to "null" by making its content empty
								subTest.log(LogStatus.INFO, "Cleared value of " + nodeName + " as per test data sheet instruction");
							} else {
								element.setTextContent(newValue);
								subTest.log(LogStatus.INFO, "Updated " + nodeName + " with value: " + newValue);
							}
						} else {
							element.setAttribute(attributeName, newValue);
							subTest.log(LogStatus.INFO, "Updated attribute " + attributeName + " of " + nodeName + " with value: " + newValue);
						}
					});
		}

		File outputDir = new File("output");
		if (!outputDir.exists())
			outputDir.mkdir();

		File savedFile = new File(outputDir, polNumber + "_updated.xml");
		Transformer transformer = TransformerFactory.newInstance().newTransformer();
		DOMSource source = new DOMSource(doc);
		StreamResult result = new StreamResult(savedFile);
		transformer.transform(source, result);
		subTest.log(LogStatus.INFO, "Updated XML saved as: " + savedFile.getPath());

		// Convert XML to Base64 and create policy via API
		String encodedXML = encodeXMLToBase64(savedFile.getPath());
		subTest.log(LogStatus.INFO, "Encoded XML to Base64 for policy creation");
		/*
		 * try { String policyNumber = createPolicy(token, encodedXML);
		 * subTest.log(LogStatus.PASS,
		 * "Policy created successfully with Policy Number: " + policyNumber); } catch
		 * (Exception e) { subTest.log(LogStatus.FAIL, "Policy creation failed: " +
		 * e.getMessage()); throw e; }
		 */

		test.appendChild(subTest);
		report.endTest(subTest);
		addTestToMainReport(test);
	}

	// Helper method to check if an element or its parent/ancestor meets the condition
	private boolean matchesCondition(Element element, String condition) {
	    if (condition.isEmpty()) {
	        return true;  // No condition specified, so always match
	    }
	    
	    String[] conditionParts = condition.split("=");
	    if (conditionParts.length != 2) {
	        return false;  // Invalid condition format
	    }
	    
	    String conditionAttribute = conditionParts[0].trim();
	    String conditionValue = conditionParts[1].trim();

	    // Traverse the element and its ancestors to check for the condition
	    Node currentNode = element;
	    while (currentNode != null && currentNode.getNodeType() == Node.ELEMENT_NODE) {
	        Element currentElement = (Element) currentNode;
	        if (currentElement.hasAttribute(conditionAttribute) &&
	            currentElement.getAttribute(conditionAttribute).equals(conditionValue)) {
	            return true;
	        }
	        currentNode = currentNode.getParentNode();  // Move up to the parent node
	    }
	    
	    return false;  // Condition not met
	}
	
	private void loadTemplate(String templateName) throws Exception {
		// subTest.log(LogStatus.INFO, "Loading XML template: " + templateName);
		try {
			File templateFile = new File(templateDir, templateName);
			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			factory.setNamespaceAware(true);
			DocumentBuilder builder = factory.newDocumentBuilder();
			doc = builder.parse(templateFile);
			// subTest.log(LogStatus.PASS, "Template loaded successfully");
		} catch (Exception e) {
			// subTest.log(LogStatus.FAIL, "Failed to load template: " + e.getMessage());
			throw e;
		}
	}

	public String encodeXMLToBase64(String filePath) throws Exception {
		File file = new File(filePath);
		FileInputStream fis = new FileInputStream(file);
		byte[] bytes = new byte[(int) file.length()];
		fis.read(bytes);
		fis.close();
		return Base64.encodeBase64String(bytes);
	}

	public String getBearerToken() throws Exception {
		FileInputStream fis = null;
		Properties prop = null;

		fis = new FileInputStream("config.properties");
		prop = new Properties();
		prop.load(fis);
		String userID = prop.getProperty("User_Name");
		String password = prop.getProperty("Password");

		// Prepare the payload
		String payload = "{ \"username\" : \"" + userID + "\", \"password\" : \"" + password + "\" }";

		// Create the HTTP POST request
		CloseableHttpClient client = HttpClients.createDefault();
		HttpPost post = new HttpPost(EnvParameters.tokenApiUrl);

		// Set headers
		post.setHeader("Content-Type", "application/json");
		post.setHeader("X-API-KEY", EnvParameters.XAPIKEY);

		// Set payload
		post.setEntity(new StringEntity(payload, ContentType.APPLICATION_JSON));

		// Execute the request
		CloseableHttpResponse response = client.execute(post);

		// Extract response body
		String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
		client.close();

		// Extract and return the token from the response
		return extractTokenFromResponse(responseBody);
	}

	public String extractTokenFromResponse(String responseBody) {
		return responseBody.split("\"token\"\\s*:\\s*\"")[1].split("\"")[0];
	}

	public String createPolicy(String token, String encodedXML) throws Exception {

		// Prepare the payload
		String payload = "{ \"encodedACORDXml\" : \"" + encodedXML + "\" }";

		// Create the HTTP POST request
		CloseableHttpClient client = HttpClients.createDefault();
		HttpPost post = new HttpPost(EnvParameters.policyApiUrl);

		// Set headers
		post.setHeader("Content-Type", "application/json");
		post.setHeader("Authorization", "Bearer " + token);
		post.setHeader("X-API-KEY", EnvParameters.XAPIKEY);

		// Set payload
		post.setEntity(new StringEntity(payload, ContentType.APPLICATION_JSON));

		// Execute the request
		CloseableHttpResponse response = client.execute(post);

		// Extract response body
		String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
		client.close();

		// Extract and return the Policy Number from the response
		return extractPolicyNumberFromResponse(responseBody);
	}

	public String extractPolicyNumberFromResponse(String responseBody) {
		JSONObject jsonResponse = new JSONObject(responseBody);
		return jsonResponse.getJSONObject("PolicyHdr").getJSONObject("PolicyHdrData").getString("PolicyNumber");
	}

	public void logError(ExtentTest localTest, Exception e, WebDriver driver) {
		String screenshotFileName = "/Screenshots/Screenshot_" + Math.random() + ".png";
		String screenshotPath = System.getProperty("user.dir") + folderPath.substring(2) + screenshotFileName;
		screenshotFileName = "./" + screenshotFileName;
		File scrFile = ((TakesScreenshot) driver).getScreenshotAs(OutputType.FILE);
		try {
			FileUtils.copyFile(scrFile, new File(screenshotPath));
		} catch (IOException e1) {

			e1.printStackTrace();
		}
		localTest.log(LogStatus.ERROR, "Exception Occured and Execution Stopped.\n" + e.getLocalizedMessage()
				+ localTest.addScreenCapture(screenshotFileName));
	}

	@AfterClass(alwaysRun = true)
	public void reporee(ITestContext result) {
		try {
			FileUtils.deleteDirectory(new File(folderPath + "/Additional Supporting Reports"));
		} catch (IOException e) {
			e.printStackTrace();
		}

		mainReport.flush();
	}

	public void addTestToMainReport(ExtentTest test) {
		ITest grandParentTest = test.getTest();
		ExtentTest parentTest = mainReport.startTest(grandParentTest.getName());
		List<com.relevantcodes.extentreports.model.Test> children = grandParentTest.getNodeList();
		for (int k = 0; k < children.size(); k++) {
			ExtentTest child = mainReport.startTest(children.get(k).getName());
			List<Log> logs = children.get(k).getLogList();

			for (int i = 0; i < logs.size(); i++) {
				child.log(logs.get(i).getLogStatus(), logs.get(i).getDetails());

			}
			parentTest.appendChild(child);
			mainReport.endTest(child);
		}

		mainReport.endTest(parentTest);
	}

}




















package fast.dataProviders;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.testng.annotations.DataProvider;
import org.testng.ITestContext;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.Iterator;


public class ReadDataFromXLSX {
	
	@DataProvider(name="ReadTestDataFromXLSX", parallel = true)
	public Object[][] getData(ITestContext context) throws IOException {
		 
		//Retrieve the 'testType' and 'filePath' parameters from testng runner
		String testParam = context.getCurrentXmlTest().getParameter("testType");
		String filePath = context.getCurrentXmlTest().getParameter("xlsxFilePath");
		String sheetName = context.getCurrentXmlTest().getParameter("sheetName");
		
		//Ensure file path is not null
		if (filePath == null) {
			throw new IllegalArgumentException("Parameter 'filePath' not provided in the testng runner");
		}
		
		List<HashMap<String,String>> dataList = new ArrayList<>();
		
		//Open the .xlsx file and read the sheet
		try (FileInputStream fis = new FileInputStream(filePath);
			Workbook workbook = new XSSFWorkbook(fis)){
			
			Sheet sheet = workbook.getSheet(sheetName);
			if (sheet == null) {
				throw new IllegalArgumentException("Required sheet not found in the xlsx file");
			}
			
			//Skip the first row and read the second row as the header
			Row headerRow = sheet.getRow(1); //Get the second row (index 1)
			if(headerRow == null) {
				throw new IllegalArgumentException("The header row (second row) is missing in the xlsx file");
			}
			
			//FormulaEvaluator instance
			FormulaEvaluator evaluator = sheet.getWorkbook().getCreationHelper().createFormulaEvaluator();
			
			int executionIndex = -1;
			int testCategoryIndex = -1;
			int columnCount = headerRow.getLastCellNum();
			
			//Find the indices of the Execution and Test_Category columns
			for (int i=0; i< columnCount; i++) {
				String headerName = headerRow.getCell(i).getStringCellValue();
				if (headerName.equalsIgnoreCase("Execution")) {
					executionIndex = i;
				}else if (headerName.equalsIgnoreCase("Test_Category")) {
					testCategoryIndex = i;
				}
			}
			
			//If 'Execution' or 'Test_Category' column is not found, throw an exception
			if(executionIndex == -1) {
				throw new IllegalArgumentException("Column 'Execution' not found in the xlsx file");
			}
			if (testCategoryIndex == -1) {
				throw new IllegalArgumentException("Column 'Test_Category' not found in the xlsx file");
			}
			
			//Process the remaining rows, starting from the third row (index 2)
			for (int rowIndex = 2; rowIndex<=sheet.getLastRowNum(); rowIndex++) {
				Row row = sheet.getRow(rowIndex);
				if (row == null) {
					continue;
				}
				
				//Get the "Execution" and "Test_Category" values
				String executionValue = row.getCell(executionIndex).getStringCellValue();
				String testCategoryValue = row.getCell(testCategoryIndex).getStringCellValue();
				
				//Check if the value in the "Execution" column is "Yes" and matches the testType
				if ("Yes".equalsIgnoreCase(executionValue) && testParam.equalsIgnoreCase(testCategoryValue)) {
					HashMap<String, String> dataMap = new HashMap<>();
					for (int i=0; i<columnCount;i++) {
						Cell cell = row.getCell(i);
						String cellValue = evaluateCell(cell,evaluator);
						//String cellValue = cell != null ? cell.toString() : "";
						dataMap.put(headerRow.getCell(i).getStringCellValue(), cellValue);
					}
					dataList.add(dataMap);
				}
			}
		}
		
		//Convert List<HashMap<String, String>> to Object[][]
		
		Object[][] data = new Object[dataList.size()][1];
		for(int i=0; i< dataList.size(); i++) {
			data[i][0] = dataList.get(i);
		}
		
		return data;
	}
	
	@DataProvider(name = "policyDataProvider", parallel = true)
    public static Object[][] policyDataProvider(ITestContext context) throws IOException {
		
		String filePath = context.getCurrentXmlTest().getParameter("xlsxFilePath");
		String policyData = context.getCurrentXmlTest().getParameter("policyData");
		String mapping = context.getCurrentXmlTest().getParameter("mapping");
		
		try {
        	
            FileInputStream fis = new FileInputStream(new File(filePath));
            Workbook workbook = new XSSFWorkbook(fis);

            Sheet policyDataSheet = workbook.getSheet(policyData);
            Sheet mappingSheet = workbook.getSheet(mapping);

            // Get total rows (excluding header)
            int rowCount = policyDataSheet.getLastRowNum();
            Object[][] data = new Object[rowCount][2];

            for (int rowIndex = 1; rowIndex <= rowCount; rowIndex++) {
                Map<String, String> policyDataMap = new HashMap<>();
                Row policyDataRow = policyDataSheet.getRow(rowIndex);

                // Read each cell and add to policyDataMap
                for (Cell cell : policyDataRow) {
                    String columnName = policyDataSheet.getRow(0).getCell(cell.getColumnIndex()).getStringCellValue();
                    String value = cell.getStringCellValue();
                    policyDataMap.put(columnName, value);
                }

                // Assign PolicyData and Mapping sheets to each row of data
                data[rowIndex - 1][0] = policyDataMap;
                data[rowIndex - 1][1] = mappingSheet;
            }

            workbook.close();
            return data;
        } catch (Exception e) {
            e.printStackTrace();
            return new Object[0][0];
        }
    }

	
	//Helper method to evaluate a cell's value or formula
	public String evaluateCell(Cell cell, FormulaEvaluator evaluator) {
		String result = "";
		
		if(cell!= null) {
			switch (cell.getCellType()) {
				
				case NUMERIC:
					// Check if the numeric value is a date
					if (DateUtil.isCellDateFormatted(cell)) {
						String cellReference = getCellReference(cell);
						//Format the date as per need (e.g., "MM/dd/yyyy")
						SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy");
						Date date = cell.getDateCellValue();
						result = dateFormat.format(date);
						
						//result = FormatDate(cell.toString(),"MM/dd/yyyy");
					}else {
						//It's a regular numeric cell, check if it's an integer
						double numericValue = cell.getNumericCellValue();
						if(numericValue == Math.floor(numericValue)) {
							//It's an integer
							result = String.valueOf((int) numericValue);
						}else {
							//it's a floating point number, keep it's precision
							result = String.valueOf(numericValue);
						}	
					}
					break;
				case STRING:
					result = cell.getStringCellValue();
					break;
				
				case FORMULA:
					//Evaluate the formula and retrieve the result
					CellValue cellValue = evaluator.evaluate(cell);
					switch (cellValue.getCellType()){
						case NUMERIC: 
							//check if the formula result is a date
							if (DateUtil.isCellDateFormatted(cell)) {
								String cellReference = getCellReference(cell);
								//Format the date if the result is a date
								SimpleDateFormat dateFormat = new SimpleDateFormat("MM/dd/yyyy");
								Date date = cell.getDateCellValue();
								result = dateFormat.format(date);
								
								//result = FormatDate(cell.toString(),"MM/dd/yyyy");
							}else {
								//It's a regular numeric cell, check if it's an integer
								double numericValue = cell.getNumericCellValue();
								if(numericValue == Math.floor(numericValue)) {
									//It's an integer
									result = String.valueOf((int) numericValue);
								}else {
									//it's a floating point number, keep it's precision
									result = String.valueOf(numericValue);
								}	
							}
							break;
						case STRING:
							result = cellValue.getStringValue();
							break;
						default:
							result = "Unsupported cell type";
							break;
					}
					break;
				default:
					result = "";
					break;
			}
		}
		return result;
	}
	
	public String FormatDate(String expectedValue, String opFormat) {
		
		//Define possible input date formats
		String[] possibleFormats = {
				"M/d/yyyy", "dd-MMM-yyyy", "MM-dd-yyyy", "yyyy-MM-dd", "yyyy/MM/dd",
				"MMM d, yyyy", "dd/MM/yyyy", "MM/dd/yyyy", "dd-MM-yyyy"};
		
		//Defined the desired output format
		SimpleDateFormat outputFormat = new SimpleDateFormat(opFormat);
		
		Date date = null;
		
		//Try parsing the date using each format in the list
		for (String format: possibleFormats) {
			try {
				SimpleDateFormat inputFormat = new SimpleDateFormat(format);
				date = inputFormat.parse(expectedValue);
				break;
			}catch (ParseException e) {
				//continue to the next format if parsing fails
			}
		}
		
		//If a valid date was parsed, format it to the desired output format
		if (date != null) {
			expectedValue = outputFormat.format(date); //This should convert the date to MM/dd/yyyy
			return expectedValue;
		}else {
			//If no format was successful return the value as-is for validation
			return expectedValue;
		}
	}
	
	public String getCellReference(Cell cell) {
		int rowIndex = cell.getRowIndex();
		int colIndex = cell.getColumnIndex();
		
		//Convert the column index to column letter
		String columnLetter = CellReference.convertNumToColString(colIndex);
		
		//Combine column letter + row number
		return columnLetter + (rowIndex+1);
	}
	
	
	
	
	@DataProvider(name = "xmlUpdateData", parallel = true)
    public static Iterator<Object[]> getPolicyData(ITestContext context) throws IOException {
    	
    	String filePath = context.getCurrentXmlTest().getParameter("xlsxFilePath");
		String policyData = context.getCurrentXmlTest().getParameter("policyData");
		
        List<Object[]> data = new ArrayList<>();
        FileInputStream file = new FileInputStream(filePath);
        Workbook workbook = new XSSFWorkbook(file);
        Sheet sheet = workbook.getSheet(policyData);

        for (Row row : sheet) {
            String testCaseName = row.getCell(0).getStringCellValue();
            String execution = row.getCell(1).getStringCellValue();
            String templateName = row.getCell(2).getStringCellValue();

            if ("Yes".equalsIgnoreCase(execution)) {
                List<Object[]> updates = new ArrayList<>();
                int i = 3; // Start from the fourth cell where nodes data begins
                
                while (i < row.getLastCellNum()) {
                    String nodeName = row.getCell(i).getStringCellValue();
                    String attributeName = row.getCell(i + 1) != null ? row.getCell(i + 1).getStringCellValue() : "";
                    String newValue = row.getCell(i + 2).getStringCellValue();
                    String condition = row.getCell(i + 3) != null ? row.getCell(i + 3).getStringCellValue() : "";

                    updates.add(new Object[]{nodeName, attributeName, newValue, condition});
                    i += 4; // Move to the next set of NodeX_Name, NodeX_Attr, NodeX_Value, NodeX_Condition
                }
                
                data.add(new Object[]{testCaseName, templateName, updates});
            }
        }
        
        workbook.close();
        file.close();

        return data.iterator();
    }

}
